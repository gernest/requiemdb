// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies,long_type_number
// @generated from protobuf file "opentelemetry/proto/trace/v1/trace.proto" (package "opentelemetry.proto.trace.v1", syntax proto3)
// tslint:disable
//
// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { KeyValue } from "./common";
import { InstrumentationScope } from "./common";
import { Resource } from "./resource";
/**
 * TracesData represents the traces data that can be stored in a persistent storage,
 * OR can be embedded by other protocols that transfer OTLP traces data but do
 * not implement the OTLP protocol.
 *
 * The main difference between this message and collector protocol is that
 * in this message there will not be any "control" or "metadata" specific to
 * OTLP protocol.
 *
 * When new fields are added into this message, the OTLP request MUST be updated
 * as well.
 *
 * @generated from protobuf message opentelemetry.proto.trace.v1.TracesData
 */
export interface TracesData {
    /**
     * An array of ResourceSpans.
     * For data coming from a single resource this array will typically contain
     * one element. Intermediary nodes that receive data from multiple origins
     * typically batch the data before forwarding further and in that case this
     * array will contain multiple elements.
     *
     * @generated from protobuf field: repeated opentelemetry.proto.trace.v1.ResourceSpans resource_spans = 1;
     */
    resourceSpans: ResourceSpans[];
}
/**
 * A collection of ScopeSpans from a Resource.
 *
 * @generated from protobuf message opentelemetry.proto.trace.v1.ResourceSpans
 */
export interface ResourceSpans {
    /**
     * The resource for the spans in this message.
     * If this field is not set then no resource info is known.
     *
     * @generated from protobuf field: opentelemetry.proto.resource.v1.Resource resource = 1;
     */
    resource?: Resource;
    /**
     * A list of ScopeSpans that originate from a resource.
     *
     * @generated from protobuf field: repeated opentelemetry.proto.trace.v1.ScopeSpans scope_spans = 2;
     */
    scopeSpans: ScopeSpans[];
    /**
     * The Schema URL, if known. This is the identifier of the Schema that the resource data
     * is recorded in. To learn more about Schema URL see
     * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
     * This schema_url applies to the data in the "resource" field. It does not apply
     * to the data in the "scope_spans" field which have their own schema_url field.
     *
     * @generated from protobuf field: string schema_url = 3;
     */
    schemaUrl: string;
}
/**
 * A collection of Spans produced by an InstrumentationScope.
 *
 * @generated from protobuf message opentelemetry.proto.trace.v1.ScopeSpans
 */
export interface ScopeSpans {
    /**
     * The instrumentation scope information for the spans in this message.
     * Semantically when InstrumentationScope isn't set, it is equivalent with
     * an empty instrumentation scope name (unknown).
     *
     * @generated from protobuf field: opentelemetry.proto.common.v1.InstrumentationScope scope = 1;
     */
    scope?: InstrumentationScope;
    /**
     * A list of Spans that originate from an instrumentation scope.
     *
     * @generated from protobuf field: repeated opentelemetry.proto.trace.v1.Span spans = 2;
     */
    spans: Span[];
    /**
     * The Schema URL, if known. This is the identifier of the Schema that the span data
     * is recorded in. To learn more about Schema URL see
     * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
     * This schema_url applies to all spans and span events in the "spans" field.
     *
     * @generated from protobuf field: string schema_url = 3;
     */
    schemaUrl: string;
}
/**
 * A Span represents a single operation performed by a single component of the system.
 *
 * The next available field id is 17.
 *
 * @generated from protobuf message opentelemetry.proto.trace.v1.Span
 */
export interface Span {
    /**
     * A unique identifier for a trace. All spans from the same trace share
     * the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes OR
     * of length other than 16 bytes is considered invalid (empty string in OTLP/JSON
     * is zero-length and thus is also invalid).
     *
     * This field is required.
     *
     * @generated from protobuf field: bytes trace_id = 1;
     */
    traceId: Uint8Array;
    /**
     * A unique identifier for a span within a trace, assigned when the span
     * is created. The ID is an 8-byte array. An ID with all zeroes OR of length
     * other than 8 bytes is considered invalid (empty string in OTLP/JSON
     * is zero-length and thus is also invalid).
     *
     * This field is required.
     *
     * @generated from protobuf field: bytes span_id = 2;
     */
    spanId: Uint8Array;
    /**
     * trace_state conveys information about request position in multiple distributed tracing graphs.
     * It is a trace_state in w3c-trace-context format: https://www.w3.org/TR/trace-context/#tracestate-header
     * See also https://github.com/w3c/distributed-tracing for more details about this field.
     *
     * @generated from protobuf field: string trace_state = 3;
     */
    traceState: string;
    /**
     * The `span_id` of this span's parent span. If this is a root span, then this
     * field must be empty. The ID is an 8-byte array.
     *
     * @generated from protobuf field: bytes parent_span_id = 4;
     */
    parentSpanId: Uint8Array;
    /**
     * Flags, a bit field.
     *
     * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
     * Context specification. To read the 8-bit W3C trace flag, use
     * `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
     *
     * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
     *
     * Bits 8 and 9 represent the 3 states of whether a span's parent
     * is remote. The states are (unknown, is not remote, is remote).
     * To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
     * To read whether the span is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
     *
     * When creating span messages, if the message is logically forwarded from another source
     * with an equivalent flags fields (i.e., usually another OTLP span message), the field SHOULD
     * be copied as-is. If creating from a source that does not have an equivalent flags field
     * (such as a runtime representation of an OpenTelemetry span), the high 22 bits MUST
     * be set to zero.
     * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
     *
     * [Optional].
     *
     * @generated from protobuf field: fixed32 flags = 16;
     */
    flags: number;
    /**
     * A description of the span's operation.
     *
     * For example, the name can be a qualified method name or a file name
     * and a line number where the operation is called. A best practice is to use
     * the same display name at the same call point in an application.
     * This makes it easier to correlate spans in different traces.
     *
     * This field is semantically required to be set to non-empty string.
     * Empty value is equivalent to an unknown span name.
     *
     * This field is required.
     *
     * @generated from protobuf field: string name = 5;
     */
    name: string;
    /**
     * Distinguishes between spans generated in a particular context. For example,
     * two spans with the same name may be distinguished using `CLIENT` (caller)
     * and `SERVER` (callee) to identify queueing latency associated with the span.
     *
     * @generated from protobuf field: opentelemetry.proto.trace.v1.Span.SpanKind kind = 6;
     */
    kind: Span_SpanKind;
    /**
     * start_time_unix_nano is the start time of the span. On the client side, this is the time
     * kept by the local machine where the span execution starts. On the server side, this
     * is the time when the server's application handler starts running.
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
     *
     * This field is semantically required and it is expected that end_time >= start_time.
     *
     * @generated from protobuf field: fixed64 start_time_unix_nano = 7;
     */
    startTimeUnixNano: number;
    /**
     * end_time_unix_nano is the end time of the span. On the client side, this is the time
     * kept by the local machine where the span execution ends. On the server side, this
     * is the time when the server application handler stops running.
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
     *
     * This field is semantically required and it is expected that end_time >= start_time.
     *
     * @generated from protobuf field: fixed64 end_time_unix_nano = 8;
     */
    endTimeUnixNano: number;
    /**
     * attributes is a collection of key/value pairs. Note, global attributes
     * like server name can be set using the resource API. Examples of attributes:
     *
     *     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
     *     "/http/server_latency": 300
     *     "example.com/myattribute": true
     *     "example.com/score": 10.239
     *
     * The OpenTelemetry API specification further restricts the allowed value types:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/common/README.md#attribute
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * @generated from protobuf field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 9;
     */
    attributes: KeyValue[];
    /**
     * dropped_attributes_count is the number of attributes that were discarded. Attributes
     * can be discarded because their keys are too long or because there are too many
     * attributes. If this value is 0, then no attributes were dropped.
     *
     * @generated from protobuf field: uint32 dropped_attributes_count = 10;
     */
    droppedAttributesCount: number;
    /**
     * events is a collection of Event items.
     *
     * @generated from protobuf field: repeated opentelemetry.proto.trace.v1.Span.Event events = 11;
     */
    events: Span_Event[];
    /**
     * dropped_events_count is the number of dropped events. If the value is 0, then no
     * events were dropped.
     *
     * @generated from protobuf field: uint32 dropped_events_count = 12;
     */
    droppedEventsCount: number;
    /**
     * links is a collection of Links, which are references from this span to a span
     * in the same or different trace.
     *
     * @generated from protobuf field: repeated opentelemetry.proto.trace.v1.Span.Link links = 13;
     */
    links: Span_Link[];
    /**
     * dropped_links_count is the number of dropped links after the maximum size was
     * enforced. If this value is 0, then no links were dropped.
     *
     * @generated from protobuf field: uint32 dropped_links_count = 14;
     */
    droppedLinksCount: number;
    /**
     * An optional final status for this span. Semantically when Status isn't set, it means
     * span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
     *
     * @generated from protobuf field: opentelemetry.proto.trace.v1.Status status = 15;
     */
    status?: Status;
}
/**
 * Event is a time-stamped annotation of the span, consisting of user-supplied
 * text description and key-value pairs.
 *
 * @generated from protobuf message opentelemetry.proto.trace.v1.Span.Event
 */
export interface Span_Event {
    /**
     * time_unix_nano is the time the event occurred.
     *
     * @generated from protobuf field: fixed64 time_unix_nano = 1;
     */
    timeUnixNano: number;
    /**
     * name of the event.
     * This field is semantically required to be set to non-empty string.
     *
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * attributes is a collection of attribute key/value pairs on the event.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * @generated from protobuf field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 3;
     */
    attributes: KeyValue[];
    /**
     * dropped_attributes_count is the number of dropped attributes. If the value is 0,
     * then no attributes were dropped.
     *
     * @generated from protobuf field: uint32 dropped_attributes_count = 4;
     */
    droppedAttributesCount: number;
}
/**
 * A pointer from the current span to another span in the same trace or in a
 * different trace. For example, this can be used in batching operations,
 * where a single batch handler processes multiple requests from different
 * traces or when the handler receives a request from a different project.
 *
 * @generated from protobuf message opentelemetry.proto.trace.v1.Span.Link
 */
export interface Span_Link {
    /**
     * A unique identifier of a trace that this linked span is part of. The ID is a
     * 16-byte array.
     *
     * @generated from protobuf field: bytes trace_id = 1;
     */
    traceId: Uint8Array;
    /**
     * A unique identifier for the linked span. The ID is an 8-byte array.
     *
     * @generated from protobuf field: bytes span_id = 2;
     */
    spanId: Uint8Array;
    /**
     * The trace_state associated with the link.
     *
     * @generated from protobuf field: string trace_state = 3;
     */
    traceState: string;
    /**
     * attributes is a collection of attribute key/value pairs on the link.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * @generated from protobuf field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 4;
     */
    attributes: KeyValue[];
    /**
     * dropped_attributes_count is the number of dropped attributes. If the value is 0,
     * then no attributes were dropped.
     *
     * @generated from protobuf field: uint32 dropped_attributes_count = 5;
     */
    droppedAttributesCount: number;
    /**
     * Flags, a bit field.
     *
     * Bits 0-7 (8 least significant bits) are the trace flags as defined in W3C Trace
     * Context specification. To read the 8-bit W3C trace flag, use
     * `flags & SPAN_FLAGS_TRACE_FLAGS_MASK`.
     *
     * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
     *
     * Bits 8 and 9 represent the 3 states of whether the link is remote.
     * The states are (unknown, is not remote, is remote).
     * To read whether the value is known, use `(flags & SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK) != 0`.
     * To read whether the link is remote, use `(flags & SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK) != 0`.
     *
     * Readers MUST NOT assume that bits 10-31 (22 most significant bits) will be zero.
     * When creating new spans, bits 10-31 (most-significant 22-bits) MUST be zero.
     *
     * [Optional].
     *
     * @generated from protobuf field: fixed32 flags = 6;
     */
    flags: number;
}
/**
 * SpanKind is the type of span. Can be used to specify additional relationships between spans
 * in addition to a parent/child relationship.
 *
 * @generated from protobuf enum opentelemetry.proto.trace.v1.Span.SpanKind
 */
export enum Span_SpanKind {
    /**
     * Unspecified. Do NOT use as default.
     * Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
     *
     * @generated from protobuf enum value: SPAN_KIND_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Indicates that the span represents an internal operation within an application,
     * as opposed to an operation happening at the boundaries. Default value.
     *
     * @generated from protobuf enum value: SPAN_KIND_INTERNAL = 1;
     */
    INTERNAL = 1,
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote network request.
     *
     * @generated from protobuf enum value: SPAN_KIND_SERVER = 2;
     */
    SERVER = 2,
    /**
     * Indicates that the span describes a request to some remote service.
     *
     * @generated from protobuf enum value: SPAN_KIND_CLIENT = 3;
     */
    CLIENT = 3,
    /**
     * Indicates that the span describes a producer sending a message to a broker.
     * Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
     * between producer and consumer spans. A PRODUCER span ends when the message was accepted
     * by the broker while the logical processing of the message might span a much longer time.
     *
     * @generated from protobuf enum value: SPAN_KIND_PRODUCER = 4;
     */
    PRODUCER = 4,
    /**
     * Indicates that the span describes consumer receiving a message from a broker.
     * Like the PRODUCER kind, there is often no direct critical path latency relationship
     * between producer and consumer spans.
     *
     * @generated from protobuf enum value: SPAN_KIND_CONSUMER = 5;
     */
    CONSUMER = 5
}
/**
 * The Status type defines a logical error model that is suitable for different
 * programming environments, including REST APIs and RPC APIs.
 *
 * @generated from protobuf message opentelemetry.proto.trace.v1.Status
 */
export interface Status {
    /**
     * A developer-facing human readable error message.
     *
     * @generated from protobuf field: string message = 2;
     */
    message: string;
    /**
     * The status code.
     *
     * @generated from protobuf field: opentelemetry.proto.trace.v1.Status.StatusCode code = 3;
     */
    code: Status_StatusCode;
}
/**
 * For the semantics of status codes see
 * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/api.md#set-status
 *
 * @generated from protobuf enum opentelemetry.proto.trace.v1.Status.StatusCode
 */
export enum Status_StatusCode {
    /**
     * The default status.
     *
     * @generated from protobuf enum value: STATUS_CODE_UNSET = 0;
     */
    UNSET = 0,
    /**
     * The Span has been validated by an Application developer or Operator to
     * have completed successfully.
     *
     * @generated from protobuf enum value: STATUS_CODE_OK = 1;
     */
    OK = 1,
    /**
     * The Span contains an error.
     *
     * @generated from protobuf enum value: STATUS_CODE_ERROR = 2;
     */
    ERROR = 2
}
/**
 * SpanFlags represents constants used to interpret the
 * Span.flags field, which is protobuf 'fixed32' type and is to
 * be used as bit-fields. Each non-zero value defined in this enum is
 * a bit-mask.  To extract the bit-field, for example, use an
 * expression like:
 *
 *   (span.flags & SPAN_FLAGS_TRACE_FLAGS_MASK)
 *
 * See https://www.w3.org/TR/trace-context-2/#trace-flags for the flag definitions.
 *
 * Note that Span flags were introduced in version 1.1 of the
 * OpenTelemetry protocol.  Older Span producers do not set this
 * field, consequently consumers should not rely on the absence of a
 * particular flag bit to indicate the presence of a particular feature.
 *
 * @generated from protobuf enum opentelemetry.proto.trace.v1.SpanFlags
 */
export enum SpanFlags {
    /**
     * The zero value for the enum. Should not be used for comparisons.
     * Instead use bitwise "and" with the appropriate mask as shown above.
     *
     * @generated from protobuf enum value: SPAN_FLAGS_DO_NOT_USE = 0;
     */
    DO_NOT_USE = 0,
    /**
     * Bits 0-7 are used for trace flags.
     *
     * @generated from protobuf enum value: SPAN_FLAGS_TRACE_FLAGS_MASK = 255;
     */
    TRACE_FLAGS_MASK = 255,
    /**
     * Bits 8 and 9 are used to indicate that the parent span or link span is remote.
     * Bit 8 (`HAS_IS_REMOTE`) indicates whether the value is known.
     * Bit 9 (`IS_REMOTE`) indicates whether the span or link is remote.
     *
     * @generated from protobuf enum value: SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK = 256;
     */
    CONTEXT_HAS_IS_REMOTE_MASK = 256,
    /**
     * @generated from protobuf enum value: SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK = 512;
     */
    CONTEXT_IS_REMOTE_MASK = 512
}
// @generated message type with reflection information, may provide speed optimized methods
class TracesData$Type extends MessageType<TracesData> {
    constructor() {
        super("opentelemetry.proto.trace.v1.TracesData", [
            { no: 1, name: "resource_spans", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceSpans }
        ]);
    }
    create(value?: PartialMessage<TracesData>): TracesData {
        const message = { resourceSpans: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TracesData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TracesData): TracesData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.trace.v1.ResourceSpans resource_spans */ 1:
                    message.resourceSpans.push(ResourceSpans.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TracesData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.trace.v1.ResourceSpans resource_spans = 1; */
        for (let i = 0; i < message.resourceSpans.length; i++)
            ResourceSpans.internalBinaryWrite(message.resourceSpans[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.trace.v1.TracesData
 */
export const TracesData = new TracesData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceSpans$Type extends MessageType<ResourceSpans> {
    constructor() {
        super("opentelemetry.proto.trace.v1.ResourceSpans", [
            { no: 1, name: "resource", kind: "message", T: () => Resource },
            { no: 2, name: "scope_spans", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScopeSpans },
            { no: 3, name: "schema_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResourceSpans>): ResourceSpans {
        const message = { scopeSpans: [], schemaUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResourceSpans>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceSpans): ResourceSpans {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* opentelemetry.proto.resource.v1.Resource resource */ 1:
                    message.resource = Resource.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* repeated opentelemetry.proto.trace.v1.ScopeSpans scope_spans */ 2:
                    message.scopeSpans.push(ScopeSpans.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string schema_url */ 3:
                    message.schemaUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceSpans, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* opentelemetry.proto.resource.v1.Resource resource = 1; */
        if (message.resource)
            Resource.internalBinaryWrite(message.resource, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated opentelemetry.proto.trace.v1.ScopeSpans scope_spans = 2; */
        for (let i = 0; i < message.scopeSpans.length; i++)
            ScopeSpans.internalBinaryWrite(message.scopeSpans[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string schema_url = 3; */
        if (message.schemaUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.schemaUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.trace.v1.ResourceSpans
 */
export const ResourceSpans = new ResourceSpans$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopeSpans$Type extends MessageType<ScopeSpans> {
    constructor() {
        super("opentelemetry.proto.trace.v1.ScopeSpans", [
            { no: 1, name: "scope", kind: "message", T: () => InstrumentationScope },
            { no: 2, name: "spans", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Span },
            { no: 3, name: "schema_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScopeSpans>): ScopeSpans {
        const message = { spans: [], schemaUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScopeSpans>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopeSpans): ScopeSpans {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* opentelemetry.proto.common.v1.InstrumentationScope scope */ 1:
                    message.scope = InstrumentationScope.internalBinaryRead(reader, reader.uint32(), options, message.scope);
                    break;
                case /* repeated opentelemetry.proto.trace.v1.Span spans */ 2:
                    message.spans.push(Span.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string schema_url */ 3:
                    message.schemaUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopeSpans, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* opentelemetry.proto.common.v1.InstrumentationScope scope = 1; */
        if (message.scope)
            InstrumentationScope.internalBinaryWrite(message.scope, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated opentelemetry.proto.trace.v1.Span spans = 2; */
        for (let i = 0; i < message.spans.length; i++)
            Span.internalBinaryWrite(message.spans[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string schema_url = 3; */
        if (message.schemaUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.schemaUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.trace.v1.ScopeSpans
 */
export const ScopeSpans = new ScopeSpans$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Span$Type extends MessageType<Span> {
    constructor() {
        super("opentelemetry.proto.trace.v1.Span", [
            { no: 1, name: "trace_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "span_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "trace_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "parent_span_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 16, name: "flags", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "kind", kind: "enum", T: () => ["opentelemetry.proto.trace.v1.Span.SpanKind", Span_SpanKind, "SPAN_KIND_"] },
            { no: 7, name: "start_time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 8, name: "end_time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 9, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue },
            { no: 10, name: "dropped_attributes_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Span_Event },
            { no: 12, name: "dropped_events_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 13, name: "links", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Span_Link },
            { no: 14, name: "dropped_links_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "status", kind: "message", T: () => Status }
        ]);
    }
    create(value?: PartialMessage<Span>): Span {
        const message = { traceId: new Uint8Array(0), spanId: new Uint8Array(0), traceState: "", parentSpanId: new Uint8Array(0), flags: 0, name: "", kind: 0, startTimeUnixNano: 0, endTimeUnixNano: 0, attributes: [], droppedAttributesCount: 0, events: [], droppedEventsCount: 0, links: [], droppedLinksCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Span>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Span): Span {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes trace_id */ 1:
                    message.traceId = reader.bytes();
                    break;
                case /* bytes span_id */ 2:
                    message.spanId = reader.bytes();
                    break;
                case /* string trace_state */ 3:
                    message.traceState = reader.string();
                    break;
                case /* bytes parent_span_id */ 4:
                    message.parentSpanId = reader.bytes();
                    break;
                case /* fixed32 flags */ 16:
                    message.flags = reader.fixed32();
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* opentelemetry.proto.trace.v1.Span.SpanKind kind */ 6:
                    message.kind = reader.int32();
                    break;
                case /* fixed64 start_time_unix_nano */ 7:
                    message.startTimeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* fixed64 end_time_unix_nano */ 8:
                    message.endTimeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* repeated opentelemetry.proto.common.v1.KeyValue attributes */ 9:
                    message.attributes.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 dropped_attributes_count */ 10:
                    message.droppedAttributesCount = reader.uint32();
                    break;
                case /* repeated opentelemetry.proto.trace.v1.Span.Event events */ 11:
                    message.events.push(Span_Event.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 dropped_events_count */ 12:
                    message.droppedEventsCount = reader.uint32();
                    break;
                case /* repeated opentelemetry.proto.trace.v1.Span.Link links */ 13:
                    message.links.push(Span_Link.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 dropped_links_count */ 14:
                    message.droppedLinksCount = reader.uint32();
                    break;
                case /* opentelemetry.proto.trace.v1.Status status */ 15:
                    message.status = Status.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Span, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes trace_id = 1; */
        if (message.traceId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.traceId);
        /* bytes span_id = 2; */
        if (message.spanId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.spanId);
        /* string trace_state = 3; */
        if (message.traceState !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.traceState);
        /* bytes parent_span_id = 4; */
        if (message.parentSpanId.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.parentSpanId);
        /* fixed32 flags = 16; */
        if (message.flags !== 0)
            writer.tag(16, WireType.Bit32).fixed32(message.flags);
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* opentelemetry.proto.trace.v1.Span.SpanKind kind = 6; */
        if (message.kind !== 0)
            writer.tag(6, WireType.Varint).int32(message.kind);
        /* fixed64 start_time_unix_nano = 7; */
        if (message.startTimeUnixNano !== 0)
            writer.tag(7, WireType.Bit64).fixed64(message.startTimeUnixNano);
        /* fixed64 end_time_unix_nano = 8; */
        if (message.endTimeUnixNano !== 0)
            writer.tag(8, WireType.Bit64).fixed64(message.endTimeUnixNano);
        /* repeated opentelemetry.proto.common.v1.KeyValue attributes = 9; */
        for (let i = 0; i < message.attributes.length; i++)
            KeyValue.internalBinaryWrite(message.attributes[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 dropped_attributes_count = 10; */
        if (message.droppedAttributesCount !== 0)
            writer.tag(10, WireType.Varint).uint32(message.droppedAttributesCount);
        /* repeated opentelemetry.proto.trace.v1.Span.Event events = 11; */
        for (let i = 0; i < message.events.length; i++)
            Span_Event.internalBinaryWrite(message.events[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* uint32 dropped_events_count = 12; */
        if (message.droppedEventsCount !== 0)
            writer.tag(12, WireType.Varint).uint32(message.droppedEventsCount);
        /* repeated opentelemetry.proto.trace.v1.Span.Link links = 13; */
        for (let i = 0; i < message.links.length; i++)
            Span_Link.internalBinaryWrite(message.links[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* uint32 dropped_links_count = 14; */
        if (message.droppedLinksCount !== 0)
            writer.tag(14, WireType.Varint).uint32(message.droppedLinksCount);
        /* opentelemetry.proto.trace.v1.Status status = 15; */
        if (message.status)
            Status.internalBinaryWrite(message.status, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.trace.v1.Span
 */
export const Span = new Span$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Span_Event$Type extends MessageType<Span_Event> {
    constructor() {
        super("opentelemetry.proto.trace.v1.Span.Event", [
            { no: 1, name: "time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue },
            { no: 4, name: "dropped_attributes_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Span_Event>): Span_Event {
        const message = { timeUnixNano: 0, name: "", attributes: [], droppedAttributesCount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Span_Event>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Span_Event): Span_Event {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* fixed64 time_unix_nano */ 1:
                    message.timeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* repeated opentelemetry.proto.common.v1.KeyValue attributes */ 3:
                    message.attributes.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 dropped_attributes_count */ 4:
                    message.droppedAttributesCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Span_Event, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* fixed64 time_unix_nano = 1; */
        if (message.timeUnixNano !== 0)
            writer.tag(1, WireType.Bit64).fixed64(message.timeUnixNano);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* repeated opentelemetry.proto.common.v1.KeyValue attributes = 3; */
        for (let i = 0; i < message.attributes.length; i++)
            KeyValue.internalBinaryWrite(message.attributes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint32 dropped_attributes_count = 4; */
        if (message.droppedAttributesCount !== 0)
            writer.tag(4, WireType.Varint).uint32(message.droppedAttributesCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.trace.v1.Span.Event
 */
export const Span_Event = new Span_Event$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Span_Link$Type extends MessageType<Span_Link> {
    constructor() {
        super("opentelemetry.proto.trace.v1.Span.Link", [
            { no: 1, name: "trace_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "span_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "trace_state", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue },
            { no: 5, name: "dropped_attributes_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "flags", kind: "scalar", T: 7 /*ScalarType.FIXED32*/ }
        ]);
    }
    create(value?: PartialMessage<Span_Link>): Span_Link {
        const message = { traceId: new Uint8Array(0), spanId: new Uint8Array(0), traceState: "", attributes: [], droppedAttributesCount: 0, flags: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Span_Link>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Span_Link): Span_Link {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes trace_id */ 1:
                    message.traceId = reader.bytes();
                    break;
                case /* bytes span_id */ 2:
                    message.spanId = reader.bytes();
                    break;
                case /* string trace_state */ 3:
                    message.traceState = reader.string();
                    break;
                case /* repeated opentelemetry.proto.common.v1.KeyValue attributes */ 4:
                    message.attributes.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 dropped_attributes_count */ 5:
                    message.droppedAttributesCount = reader.uint32();
                    break;
                case /* fixed32 flags */ 6:
                    message.flags = reader.fixed32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Span_Link, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes trace_id = 1; */
        if (message.traceId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.traceId);
        /* bytes span_id = 2; */
        if (message.spanId.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.spanId);
        /* string trace_state = 3; */
        if (message.traceState !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.traceState);
        /* repeated opentelemetry.proto.common.v1.KeyValue attributes = 4; */
        for (let i = 0; i < message.attributes.length; i++)
            KeyValue.internalBinaryWrite(message.attributes[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 dropped_attributes_count = 5; */
        if (message.droppedAttributesCount !== 0)
            writer.tag(5, WireType.Varint).uint32(message.droppedAttributesCount);
        /* fixed32 flags = 6; */
        if (message.flags !== 0)
            writer.tag(6, WireType.Bit32).fixed32(message.flags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.trace.v1.Span.Link
 */
export const Span_Link = new Span_Link$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Status$Type extends MessageType<Status> {
    constructor() {
        super("opentelemetry.proto.trace.v1.Status", [
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "code", kind: "enum", T: () => ["opentelemetry.proto.trace.v1.Status.StatusCode", Status_StatusCode, "STATUS_CODE_"] }
        ]);
    }
    create(value?: PartialMessage<Status>): Status {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Status>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Status): Status {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* opentelemetry.proto.trace.v1.Status.StatusCode code */ 3:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Status, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* opentelemetry.proto.trace.v1.Status.StatusCode code = 3; */
        if (message.code !== 0)
            writer.tag(3, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.trace.v1.Status
 */
export const Status = new Status$Type();
