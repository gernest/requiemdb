// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies,long_type_number
// @generated from protobuf file "opentelemetry/proto/metrics/v1/metrics.proto" (package "opentelemetry.proto.metrics.v1", syntax proto3)
// tslint:disable
//
// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { KeyValue } from "./common";
import { InstrumentationScope } from "./common";
import { Resource } from "./resource";
/**
 * MetricsData represents the metrics data that can be stored in a persistent
 * storage, OR can be embedded by other protocols that transfer OTLP metrics
 * data but do not implement the OTLP protocol.
 *
 * The main difference between this message and collector protocol is that
 * in this message there will not be any "control" or "metadata" specific to
 * OTLP protocol.
 *
 * When new fields are added into this message, the OTLP request MUST be updated
 * as well.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.MetricsData
 */
export interface MetricsData {
    /**
     * An array of ResourceMetrics.
     * For data coming from a single resource this array will typically contain
     * one element. Intermediary nodes that receive data from multiple origins
     * typically batch the data before forwarding further and in that case this
     * array will contain multiple elements.
     *
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.ResourceMetrics resource_metrics = 1;
     */
    resourceMetrics: ResourceMetrics[];
}
/**
 * A collection of ScopeMetrics from a Resource.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.ResourceMetrics
 */
export interface ResourceMetrics {
    /**
     * The resource for the metrics in this message.
     * If this field is not set then no resource info is known.
     *
     * @generated from protobuf field: opentelemetry.proto.resource.v1.Resource resource = 1;
     */
    resource?: Resource;
    /**
     * A list of metrics that originate from a resource.
     *
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.ScopeMetrics scope_metrics = 2;
     */
    scopeMetrics: ScopeMetrics[];
    /**
     * The Schema URL, if known. This is the identifier of the Schema that the resource data
     * is recorded in. To learn more about Schema URL see
     * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
     * This schema_url applies to the data in the "resource" field. It does not apply
     * to the data in the "scope_metrics" field which have their own schema_url field.
     *
     * @generated from protobuf field: string schema_url = 3;
     */
    schemaUrl: string;
}
/**
 * A collection of Metrics produced by an Scope.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.ScopeMetrics
 */
export interface ScopeMetrics {
    /**
     * The instrumentation scope information for the metrics in this message.
     * Semantically when InstrumentationScope isn't set, it is equivalent with
     * an empty instrumentation scope name (unknown).
     *
     * @generated from protobuf field: opentelemetry.proto.common.v1.InstrumentationScope scope = 1;
     */
    scope?: InstrumentationScope;
    /**
     * A list of metrics that originate from an instrumentation library.
     *
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.Metric metrics = 2;
     */
    metrics: Metric[];
    /**
     * The Schema URL, if known. This is the identifier of the Schema that the metric data
     * is recorded in. To learn more about Schema URL see
     * https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
     * This schema_url applies to all metrics in the "metrics" field.
     *
     * @generated from protobuf field: string schema_url = 3;
     */
    schemaUrl: string;
}
/**
 * Defines a Metric which has one or more timeseries.  The following is a
 * brief summary of the Metric data model.  For more details, see:
 *
 *   https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/data-model.md
 *
 *
 * The data model and relation between entities is shown in the
 * diagram below. Here, "DataPoint" is the term used to refer to any
 * one of the specific data point value types, and "points" is the term used
 * to refer to any one of the lists of points contained in the Metric.
 *
 * - Metric is composed of a metadata and data.
 * - Metadata part contains a name, description, unit.
 * - Data is one of the possible types (Sum, Gauge, Histogram, Summary).
 * - DataPoint contains timestamps, attributes, and one of the possible value type
 *   fields.
 *
 *     Metric
 *  +------------+
 *  |name        |
 *  |description |
 *  |unit        |     +------------------------------------+
 *  |data        |---> |Gauge, Sum, Histogram, Summary, ... |
 *  +------------+     +------------------------------------+
 *
 *    Data [One of Gauge, Sum, Histogram, Summary, ...]
 *  +-----------+
 *  |...        |  // Metadata about the Data.
 *  |points     |--+
 *  +-----------+  |
 *                 |      +---------------------------+
 *                 |      |DataPoint 1                |
 *                 v      |+------+------+   +------+ |
 *              +-----+   ||label |label |...|label | |
 *              |  1  |-->||value1|value2|...|valueN| |
 *              +-----+   |+------+------+   +------+ |
 *              |  .  |   |+-----+                    |
 *              |  .  |   ||value|                    |
 *              |  .  |   |+-----+                    |
 *              |  .  |   +---------------------------+
 *              |  .  |                   .
 *              |  .  |                   .
 *              |  .  |                   .
 *              |  .  |   +---------------------------+
 *              |  .  |   |DataPoint M                |
 *              +-----+   |+------+------+   +------+ |
 *              |  M  |-->||label |label |...|label | |
 *              +-----+   ||value1|value2|...|valueN| |
 *                        |+------+------+   +------+ |
 *                        |+-----+                    |
 *                        ||value|                    |
 *                        |+-----+                    |
 *                        +---------------------------+
 *
 * Each distinct type of DataPoint represents the output of a specific
 * aggregation function, the result of applying the DataPoint's
 * associated function of to one or more measurements.
 *
 * All DataPoint types have three common fields:
 * - Attributes includes key-value pairs associated with the data point
 * - TimeUnixNano is required, set to the end time of the aggregation
 * - StartTimeUnixNano is optional, but strongly encouraged for DataPoints
 *   having an AggregationTemporality field, as discussed below.
 *
 * Both TimeUnixNano and StartTimeUnixNano values are expressed as
 * UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
 *
 * # TimeUnixNano
 *
 * This field is required, having consistent interpretation across
 * DataPoint types.  TimeUnixNano is the moment corresponding to when
 * the data point's aggregate value was captured.
 *
 * Data points with the 0 value for TimeUnixNano SHOULD be rejected
 * by consumers.
 *
 * # StartTimeUnixNano
 *
 * StartTimeUnixNano in general allows detecting when a sequence of
 * observations is unbroken.  This field indicates to consumers the
 * start time for points with cumulative and delta
 * AggregationTemporality, and it should be included whenever possible
 * to support correct rate calculation.  Although it may be omitted
 * when the start time is truly unknown, setting StartTimeUnixNano is
 * strongly encouraged.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.Metric
 */
export interface Metric {
    /**
     * name of the metric.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * description of the metric, which can be used in documentation.
     *
     * @generated from protobuf field: string description = 2;
     */
    description: string;
    /**
     * unit in which the metric value is reported. Follows the format
     * described by http://unitsofmeasure.org/ucum.html.
     *
     * @generated from protobuf field: string unit = 3;
     */
    unit: string;
    /**
     * @generated from protobuf oneof: data
     */
    data: {
        oneofKind: "gauge";
        /**
         * @generated from protobuf field: opentelemetry.proto.metrics.v1.Gauge gauge = 5;
         */
        gauge: Gauge;
    } | {
        oneofKind: "sum";
        /**
         * @generated from protobuf field: opentelemetry.proto.metrics.v1.Sum sum = 7;
         */
        sum: Sum;
    } | {
        oneofKind: "histogram";
        /**
         * @generated from protobuf field: opentelemetry.proto.metrics.v1.Histogram histogram = 9;
         */
        histogram: Histogram;
    } | {
        oneofKind: "exponentialHistogram";
        /**
         * @generated from protobuf field: opentelemetry.proto.metrics.v1.ExponentialHistogram exponential_histogram = 10;
         */
        exponentialHistogram: ExponentialHistogram;
    } | {
        oneofKind: "summary";
        /**
         * @generated from protobuf field: opentelemetry.proto.metrics.v1.Summary summary = 11;
         */
        summary: Summary;
    } | {
        oneofKind: undefined;
    };
    /**
     * Additional metadata attributes that describe the metric. [Optional].
     * Attributes are non-identifying.
     * Consumers SHOULD NOT need to be aware of these attributes.
     * These attributes MAY be used to encode information allowing
     * for lossless roundtrip translation to / from another data model.
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * @generated from protobuf field: repeated opentelemetry.proto.common.v1.KeyValue metadata = 12;
     */
    metadata: KeyValue[];
}
/**
 * Gauge represents the type of a scalar metric that always exports the
 * "current value" for every data point. It should be used for an "unknown"
 * aggregation.
 *
 * A Gauge does not support different aggregation temporalities. Given the
 * aggregation is unknown, points cannot be combined using the same
 * aggregation, regardless of aggregation temporalities. Therefore,
 * AggregationTemporality is not included. Consequently, this also means
 * "StartTimeUnixNano" is ignored for all data points.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.Gauge
 */
export interface Gauge {
    /**
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.NumberDataPoint data_points = 1;
     */
    dataPoints: NumberDataPoint[];
}
/**
 * Sum represents the type of a scalar metric that is calculated as a sum of all
 * reported measurements over a time interval.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.Sum
 */
export interface Sum {
    /**
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.NumberDataPoint data_points = 1;
     */
    dataPoints: NumberDataPoint[];
    /**
     * aggregation_temporality describes if the aggregator reports delta changes
     * since last report time, or cumulative changes since a fixed start time.
     *
     * @generated from protobuf field: opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality = 2;
     */
    aggregationTemporality: AggregationTemporality;
    /**
     * If "true" means that the sum is monotonic.
     *
     * @generated from protobuf field: bool is_monotonic = 3;
     */
    isMonotonic: boolean;
}
/**
 * Histogram represents the type of a metric that is calculated by aggregating
 * as a Histogram of all reported measurements over a time interval.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.Histogram
 */
export interface Histogram {
    /**
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.HistogramDataPoint data_points = 1;
     */
    dataPoints: HistogramDataPoint[];
    /**
     * aggregation_temporality describes if the aggregator reports delta changes
     * since last report time, or cumulative changes since a fixed start time.
     *
     * @generated from protobuf field: opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality = 2;
     */
    aggregationTemporality: AggregationTemporality;
}
/**
 * ExponentialHistogram represents the type of a metric that is calculated by aggregating
 * as a ExponentialHistogram of all reported double measurements over a time interval.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.ExponentialHistogram
 */
export interface ExponentialHistogram {
    /**
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint data_points = 1;
     */
    dataPoints: ExponentialHistogramDataPoint[];
    /**
     * aggregation_temporality describes if the aggregator reports delta changes
     * since last report time, or cumulative changes since a fixed start time.
     *
     * @generated from protobuf field: opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality = 2;
     */
    aggregationTemporality: AggregationTemporality;
}
/**
 * Summary metric data are used to convey quantile summaries,
 * a Prometheus (see: https://prometheus.io/docs/concepts/metric_types/#summary)
 * and OpenMetrics (see: https://github.com/OpenObservability/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prometheus.proto#L45)
 * data type. These data points cannot always be merged in a meaningful way.
 * While they can be useful in some applications, histogram data points are
 * recommended for new applications.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.Summary
 */
export interface Summary {
    /**
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.SummaryDataPoint data_points = 1;
     */
    dataPoints: SummaryDataPoint[];
}
/**
 * NumberDataPoint is a single data point in a timeseries that describes the
 * time-varying scalar value of a metric.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.NumberDataPoint
 */
export interface NumberDataPoint {
    /**
     * The set of key/value pairs that uniquely identify the timeseries from
     * where this point belongs. The list may be empty (may contain 0 elements).
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * @generated from protobuf field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 7;
     */
    attributes: KeyValue[];
    /**
     * StartTimeUnixNano is optional but strongly encouraged, see the
     * the detailed comments above Metric.
     *
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     *
     * @generated from protobuf field: fixed64 start_time_unix_nano = 2;
     */
    startTimeUnixNano: number;
    /**
     * TimeUnixNano is required, see the detailed comments above Metric.
     *
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     *
     * @generated from protobuf field: fixed64 time_unix_nano = 3;
     */
    timeUnixNano: number;
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "asDouble";
        /**
         * @generated from protobuf field: double as_double = 4;
         */
        asDouble: number;
    } | {
        oneofKind: "asInt";
        /**
         * @generated from protobuf field: sfixed64 as_int = 6;
         */
        asInt: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * (Optional) List of exemplars collected from
     * measurements that were used to form the data point
     *
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.Exemplar exemplars = 5;
     */
    exemplars: Exemplar[];
    /**
     * Flags that apply to this specific data point.  See DataPointFlags
     * for the available flags and their meaning.
     *
     * @generated from protobuf field: uint32 flags = 8;
     */
    flags: number;
}
/**
 * HistogramDataPoint is a single data point in a timeseries that describes the
 * time-varying values of a Histogram. A Histogram contains summary statistics
 * for a population of values, it may optionally contain the distribution of
 * those values across a set of buckets.
 *
 * If the histogram contains the distribution of values, then both
 * "explicit_bounds" and "bucket counts" fields must be defined.
 * If the histogram does not contain the distribution of values, then both
 * "explicit_bounds" and "bucket_counts" must be omitted and only "count" and
 * "sum" are known.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.HistogramDataPoint
 */
export interface HistogramDataPoint {
    /**
     * The set of key/value pairs that uniquely identify the timeseries from
     * where this point belongs. The list may be empty (may contain 0 elements).
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * @generated from protobuf field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 9;
     */
    attributes: KeyValue[];
    /**
     * StartTimeUnixNano is optional but strongly encouraged, see the
     * the detailed comments above Metric.
     *
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     *
     * @generated from protobuf field: fixed64 start_time_unix_nano = 2;
     */
    startTimeUnixNano: number;
    /**
     * TimeUnixNano is required, see the detailed comments above Metric.
     *
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     *
     * @generated from protobuf field: fixed64 time_unix_nano = 3;
     */
    timeUnixNano: number;
    /**
     * count is the number of values in the population. Must be non-negative. This
     * value must be equal to the sum of the "count" fields in buckets if a
     * histogram is provided.
     *
     * @generated from protobuf field: fixed64 count = 4;
     */
    count: number;
    /**
     * sum of the values in the population. If count is zero then this field
     * must be zero.
     *
     * Note: Sum should only be filled out when measuring non-negative discrete
     * events, and is assumed to be monotonic over the values of these events.
     * Negative events *can* be recorded, but sum should not be filled out when
     * doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
     * see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#histogram
     *
     * @generated from protobuf field: optional double sum = 5;
     */
    sum?: number;
    /**
     * bucket_counts is an optional field contains the count values of histogram
     * for each bucket.
     *
     * The sum of the bucket_counts must equal the value in the count field.
     *
     * The number of elements in bucket_counts array must be by one greater than
     * the number of elements in explicit_bounds array.
     *
     * @generated from protobuf field: repeated fixed64 bucket_counts = 6;
     */
    bucketCounts: number[];
    /**
     * explicit_bounds specifies buckets with explicitly defined bounds for values.
     *
     * The boundaries for bucket at index i are:
     *
     * (-infinity, explicit_bounds[i]] for i == 0
     * (explicit_bounds[i-1], explicit_bounds[i]] for 0 < i < size(explicit_bounds)
     * (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)
     *
     * The values in the explicit_bounds array must be strictly increasing.
     *
     * Histogram buckets are inclusive of their upper boundary, except the last
     * bucket where the boundary is at infinity. This format is intentionally
     * compatible with the OpenMetrics histogram definition.
     *
     * @generated from protobuf field: repeated double explicit_bounds = 7;
     */
    explicitBounds: number[];
    /**
     * (Optional) List of exemplars collected from
     * measurements that were used to form the data point
     *
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.Exemplar exemplars = 8;
     */
    exemplars: Exemplar[];
    /**
     * Flags that apply to this specific data point.  See DataPointFlags
     * for the available flags and their meaning.
     *
     * @generated from protobuf field: uint32 flags = 10;
     */
    flags: number;
    /**
     * min is the minimum value over (start_time, end_time].
     *
     * @generated from protobuf field: optional double min = 11;
     */
    min?: number;
    /**
     * max is the maximum value over (start_time, end_time].
     *
     * @generated from protobuf field: optional double max = 12;
     */
    max?: number;
}
/**
 * ExponentialHistogramDataPoint is a single data point in a timeseries that describes the
 * time-varying values of a ExponentialHistogram of double values. A ExponentialHistogram contains
 * summary statistics for a population of values, it may optionally contain the
 * distribution of those values across a set of buckets.
 *
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
 */
export interface ExponentialHistogramDataPoint {
    /**
     * The set of key/value pairs that uniquely identify the timeseries from
     * where this point belongs. The list may be empty (may contain 0 elements).
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * @generated from protobuf field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 1;
     */
    attributes: KeyValue[];
    /**
     * StartTimeUnixNano is optional but strongly encouraged, see the
     * the detailed comments above Metric.
     *
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     *
     * @generated from protobuf field: fixed64 start_time_unix_nano = 2;
     */
    startTimeUnixNano: number;
    /**
     * TimeUnixNano is required, see the detailed comments above Metric.
     *
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     *
     * @generated from protobuf field: fixed64 time_unix_nano = 3;
     */
    timeUnixNano: number;
    /**
     * count is the number of values in the population. Must be
     * non-negative. This value must be equal to the sum of the "bucket_counts"
     * values in the positive and negative Buckets plus the "zero_count" field.
     *
     * @generated from protobuf field: fixed64 count = 4;
     */
    count: number;
    /**
     * sum of the values in the population. If count is zero then this field
     * must be zero.
     *
     * Note: Sum should only be filled out when measuring non-negative discrete
     * events, and is assumed to be monotonic over the values of these events.
     * Negative events *can* be recorded, but sum should not be filled out when
     * doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
     * see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#histogram
     *
     * @generated from protobuf field: optional double sum = 5;
     */
    sum?: number;
    /**
     * scale describes the resolution of the histogram.  Boundaries are
     * located at powers of the base, where:
     *
     *   base = (2^(2^-scale))
     *
     * The histogram bucket identified by `index`, a signed integer,
     * contains values that are greater than (base^index) and
     * less than or equal to (base^(index+1)).
     *
     * The positive and negative ranges of the histogram are expressed
     * separately.  Negative values are mapped by their absolute value
     * into the negative range using the same scale as the positive range.
     *
     * scale is not restricted by the protocol, as the permissible
     * values depend on the range of the data.
     *
     * @generated from protobuf field: sint32 scale = 6;
     */
    scale: number;
    /**
     * zero_count is the count of values that are either exactly zero or
     * within the region considered zero by the instrumentation at the
     * tolerated degree of precision.  This bucket stores values that
     * cannot be expressed using the standard exponential formula as
     * well as values that have been rounded to zero.
     *
     * Implementations MAY consider the zero bucket to have probability
     * mass equal to (zero_count / count).
     *
     * @generated from protobuf field: fixed64 zero_count = 7;
     */
    zeroCount: number;
    /**
     * positive carries the positive range of exponential bucket counts.
     *
     * @generated from protobuf field: opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets positive = 8;
     */
    positive?: ExponentialHistogramDataPoint_Buckets;
    /**
     * negative carries the negative range of exponential bucket counts.
     *
     * @generated from protobuf field: opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets negative = 9;
     */
    negative?: ExponentialHistogramDataPoint_Buckets;
    /**
     * Flags that apply to this specific data point.  See DataPointFlags
     * for the available flags and their meaning.
     *
     * @generated from protobuf field: uint32 flags = 10;
     */
    flags: number;
    /**
     * (Optional) List of exemplars collected from
     * measurements that were used to form the data point
     *
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.Exemplar exemplars = 11;
     */
    exemplars: Exemplar[];
    /**
     * min is the minimum value over (start_time, end_time].
     *
     * @generated from protobuf field: optional double min = 12;
     */
    min?: number;
    /**
     * max is the maximum value over (start_time, end_time].
     *
     * @generated from protobuf field: optional double max = 13;
     */
    max?: number;
    /**
     * ZeroThreshold may be optionally set to convey the width of the zero
     * region. Where the zero region is defined as the closed interval
     * [-ZeroThreshold, ZeroThreshold].
     * When ZeroThreshold is 0, zero count bucket stores values that cannot be
     * expressed using the standard exponential formula as well as values that
     * have been rounded to zero.
     *
     * @generated from protobuf field: double zero_threshold = 14;
     */
    zeroThreshold: number;
}
/**
 * Buckets are a set of bucket counts, encoded in a contiguous array
 * of counts.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
 */
export interface ExponentialHistogramDataPoint_Buckets {
    /**
     * Offset is the bucket index of the first entry in the bucket_counts array.
     *
     * Note: This uses a varint encoding as a simple form of compression.
     *
     * @generated from protobuf field: sint32 offset = 1;
     */
    offset: number;
    /**
     * bucket_counts is an array of count values, where bucket_counts[i] carries
     * the count of the bucket at index (offset+i). bucket_counts[i] is the count
     * of values greater than base^(offset+i) and less than or equal to
     * base^(offset+i+1).
     *
     * Note: By contrast, the explicit HistogramDataPoint uses
     * fixed64.  This field is expected to have many buckets,
     * especially zeros, so uint64 has been selected to ensure
     * varint encoding.
     *
     * @generated from protobuf field: repeated uint64 bucket_counts = 2;
     */
    bucketCounts: number[];
}
/**
 * SummaryDataPoint is a single data point in a timeseries that describes the
 * time-varying values of a Summary metric.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.SummaryDataPoint
 */
export interface SummaryDataPoint {
    /**
     * The set of key/value pairs that uniquely identify the timeseries from
     * where this point belongs. The list may be empty (may contain 0 elements).
     * Attribute keys MUST be unique (it is not allowed to have more than one
     * attribute with the same key).
     *
     * @generated from protobuf field: repeated opentelemetry.proto.common.v1.KeyValue attributes = 7;
     */
    attributes: KeyValue[];
    /**
     * StartTimeUnixNano is optional but strongly encouraged, see the
     * the detailed comments above Metric.
     *
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     *
     * @generated from protobuf field: fixed64 start_time_unix_nano = 2;
     */
    startTimeUnixNano: number;
    /**
     * TimeUnixNano is required, see the detailed comments above Metric.
     *
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     *
     * @generated from protobuf field: fixed64 time_unix_nano = 3;
     */
    timeUnixNano: number;
    /**
     * count is the number of values in the population. Must be non-negative.
     *
     * @generated from protobuf field: fixed64 count = 4;
     */
    count: number;
    /**
     * sum of the values in the population. If count is zero then this field
     * must be zero.
     *
     * Note: Sum should only be filled out when measuring non-negative discrete
     * events, and is assumed to be monotonic over the values of these events.
     * Negative events *can* be recorded, but sum should not be filled out when
     * doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
     * see: https://github.com/OpenObservability/OpenMetrics/blob/main/specification/OpenMetrics.md#summary
     *
     * @generated from protobuf field: double sum = 5;
     */
    sum: number;
    /**
     * (Optional) list of values at different quantiles of the distribution calculated
     * from the current snapshot. The quantiles must be strictly increasing.
     *
     * @generated from protobuf field: repeated opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile quantile_values = 6;
     */
    quantileValues: SummaryDataPoint_ValueAtQuantile[];
    /**
     * Flags that apply to this specific data point.  See DataPointFlags
     * for the available flags and their meaning.
     *
     * @generated from protobuf field: uint32 flags = 8;
     */
    flags: number;
}
/**
 * Represents the value at a given quantile of a distribution.
 *
 * To record Min and Max values following conventions are used:
 * - The 1.0 quantile is equivalent to the maximum value observed.
 * - The 0.0 quantile is equivalent to the minimum value observed.
 *
 * See the following issue for more context:
 * https://github.com/open-telemetry/opentelemetry-proto/issues/125
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
 */
export interface SummaryDataPoint_ValueAtQuantile {
    /**
     * The quantile of a distribution. Must be in the interval
     * [0.0, 1.0].
     *
     * @generated from protobuf field: double quantile = 1;
     */
    quantile: number;
    /**
     * The value at the given quantile of a distribution.
     *
     * Quantile values must NOT be negative.
     *
     * @generated from protobuf field: double value = 2;
     */
    value: number;
}
/**
 * A representation of an exemplar, which is a sample input measurement.
 * Exemplars also hold information about the environment when the measurement
 * was recorded, for example the span and trace ID of the active span when the
 * exemplar was recorded.
 *
 * @generated from protobuf message opentelemetry.proto.metrics.v1.Exemplar
 */
export interface Exemplar {
    /**
     * The set of key/value pairs that were filtered out by the aggregator, but
     * recorded alongside the original measurement. Only key/value pairs that were
     * filtered out by the aggregator should be included
     *
     * @generated from protobuf field: repeated opentelemetry.proto.common.v1.KeyValue filtered_attributes = 7;
     */
    filteredAttributes: KeyValue[];
    /**
     * time_unix_nano is the exact time when this exemplar was recorded
     *
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
     * 1970.
     *
     * @generated from protobuf field: fixed64 time_unix_nano = 2;
     */
    timeUnixNano: number;
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "asDouble";
        /**
         * @generated from protobuf field: double as_double = 3;
         */
        asDouble: number;
    } | {
        oneofKind: "asInt";
        /**
         * @generated from protobuf field: sfixed64 as_int = 6;
         */
        asInt: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * (Optional) Span ID of the exemplar trace.
     * span_id may be missing if the measurement is not recorded inside a trace
     * or if the trace is not sampled.
     *
     * @generated from protobuf field: bytes span_id = 4;
     */
    spanId: Uint8Array;
    /**
     * (Optional) Trace ID of the exemplar trace.
     * trace_id may be missing if the measurement is not recorded inside a trace
     * or if the trace is not sampled.
     *
     * @generated from protobuf field: bytes trace_id = 5;
     */
    traceId: Uint8Array;
}
/**
 * AggregationTemporality defines how a metric aggregator reports aggregated
 * values. It describes how those values relate to the time interval over
 * which they are aggregated.
 *
 * @generated from protobuf enum opentelemetry.proto.metrics.v1.AggregationTemporality
 */
export enum AggregationTemporality {
    /**
     * UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
     *
     * @generated from protobuf enum value: AGGREGATION_TEMPORALITY_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * DELTA is an AggregationTemporality for a metric aggregator which reports
     * changes since last report time. Successive metrics contain aggregation of
     * values from continuous and non-overlapping intervals.
     *
     * The values for a DELTA metric are based only on the time interval
     * associated with one measurement cycle. There is no dependency on
     * previous measurements like is the case for CUMULATIVE metrics.
     *
     * For example, consider a system measuring the number of requests that
     * it receives and reports the sum of these requests every second as a
     * DELTA metric:
     *
     *   1. The system starts receiving at time=t_0.
     *   2. A request is received, the system measures 1 request.
     *   3. A request is received, the system measures 1 request.
     *   4. A request is received, the system measures 1 request.
     *   5. The 1 second collection cycle ends. A metric is exported for the
     *      number of requests received over the interval of time t_0 to
     *      t_0+1 with a value of 3.
     *   6. A request is received, the system measures 1 request.
     *   7. A request is received, the system measures 1 request.
     *   8. The 1 second collection cycle ends. A metric is exported for the
     *      number of requests received over the interval of time t_0+1 to
     *      t_0+2 with a value of 2.
     *
     * @generated from protobuf enum value: AGGREGATION_TEMPORALITY_DELTA = 1;
     */
    DELTA = 1,
    /**
     * CUMULATIVE is an AggregationTemporality for a metric aggregator which
     * reports changes since a fixed start time. This means that current values
     * of a CUMULATIVE metric depend on all previous measurements since the
     * start time. Because of this, the sender is required to retain this state
     * in some form. If this state is lost or invalidated, the CUMULATIVE metric
     * values MUST be reset and a new fixed start time following the last
     * reported measurement time sent MUST be used.
     *
     * For example, consider a system measuring the number of requests that
     * it receives and reports the sum of these requests every second as a
     * CUMULATIVE metric:
     *
     *   1. The system starts receiving at time=t_0.
     *   2. A request is received, the system measures 1 request.
     *   3. A request is received, the system measures 1 request.
     *   4. A request is received, the system measures 1 request.
     *   5. The 1 second collection cycle ends. A metric is exported for the
     *      number of requests received over the interval of time t_0 to
     *      t_0+1 with a value of 3.
     *   6. A request is received, the system measures 1 request.
     *   7. A request is received, the system measures 1 request.
     *   8. The 1 second collection cycle ends. A metric is exported for the
     *      number of requests received over the interval of time t_0 to
     *      t_0+2 with a value of 5.
     *   9. The system experiences a fault and loses state.
     *   10. The system recovers and resumes receiving at time=t_1.
     *   11. A request is received, the system measures 1 request.
     *   12. The 1 second collection cycle ends. A metric is exported for the
     *      number of requests received over the interval of time t_1 to
     *      t_0+1 with a value of 1.
     *
     * Note: Even though, when reporting changes since last report time, using
     * CUMULATIVE is valid, it is not recommended. This may cause problems for
     * systems that do not use start_time to determine when the aggregation
     * value was reset (e.g. Prometheus).
     *
     * @generated from protobuf enum value: AGGREGATION_TEMPORALITY_CUMULATIVE = 2;
     */
    CUMULATIVE = 2
}
/**
 * DataPointFlags is defined as a protobuf 'uint32' type and is to be used as a
 * bit-field representing 32 distinct boolean flags.  Each flag defined in this
 * enum is a bit-mask.  To test the presence of a single flag in the flags of
 * a data point, for example, use an expression like:
 *
 *   (point.flags & DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK) == DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK
 *
 *
 * @generated from protobuf enum opentelemetry.proto.metrics.v1.DataPointFlags
 */
export enum DataPointFlags {
    /**
     * The zero value for the enum. Should not be used for comparisons.
     * Instead use bitwise "and" with the appropriate mask as shown above.
     *
     * @generated from protobuf enum value: DATA_POINT_FLAGS_DO_NOT_USE = 0;
     */
    DO_NOT_USE = 0,
    /**
     * This DataPoint is valid but has no recorded value.  This value
     * SHOULD be used to reflect explicitly missing data in a series, as
     * for an equivalent to the Prometheus "staleness marker".
     *
     * @generated from protobuf enum value: DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK = 1;
     */
    NO_RECORDED_VALUE_MASK = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class MetricsData$Type extends MessageType<MetricsData> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.MetricsData", [
            { no: 1, name: "resource_metrics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ResourceMetrics }
        ]);
    }
    create(value?: PartialMessage<MetricsData>): MetricsData {
        const message = { resourceMetrics: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MetricsData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MetricsData): MetricsData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.metrics.v1.ResourceMetrics resource_metrics */ 1:
                    message.resourceMetrics.push(ResourceMetrics.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MetricsData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.metrics.v1.ResourceMetrics resource_metrics = 1; */
        for (let i = 0; i < message.resourceMetrics.length; i++)
            ResourceMetrics.internalBinaryWrite(message.resourceMetrics[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.MetricsData
 */
export const MetricsData = new MetricsData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResourceMetrics$Type extends MessageType<ResourceMetrics> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.ResourceMetrics", [
            { no: 1, name: "resource", kind: "message", T: () => Resource },
            { no: 2, name: "scope_metrics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ScopeMetrics },
            { no: 3, name: "schema_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResourceMetrics>): ResourceMetrics {
        const message = { scopeMetrics: [], schemaUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResourceMetrics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResourceMetrics): ResourceMetrics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* opentelemetry.proto.resource.v1.Resource resource */ 1:
                    message.resource = Resource.internalBinaryRead(reader, reader.uint32(), options, message.resource);
                    break;
                case /* repeated opentelemetry.proto.metrics.v1.ScopeMetrics scope_metrics */ 2:
                    message.scopeMetrics.push(ScopeMetrics.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string schema_url */ 3:
                    message.schemaUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResourceMetrics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* opentelemetry.proto.resource.v1.Resource resource = 1; */
        if (message.resource)
            Resource.internalBinaryWrite(message.resource, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated opentelemetry.proto.metrics.v1.ScopeMetrics scope_metrics = 2; */
        for (let i = 0; i < message.scopeMetrics.length; i++)
            ScopeMetrics.internalBinaryWrite(message.scopeMetrics[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string schema_url = 3; */
        if (message.schemaUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.schemaUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.ResourceMetrics
 */
export const ResourceMetrics = new ResourceMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScopeMetrics$Type extends MessageType<ScopeMetrics> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.ScopeMetrics", [
            { no: 1, name: "scope", kind: "message", T: () => InstrumentationScope },
            { no: 2, name: "metrics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Metric },
            { no: 3, name: "schema_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScopeMetrics>): ScopeMetrics {
        const message = { metrics: [], schemaUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScopeMetrics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScopeMetrics): ScopeMetrics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* opentelemetry.proto.common.v1.InstrumentationScope scope */ 1:
                    message.scope = InstrumentationScope.internalBinaryRead(reader, reader.uint32(), options, message.scope);
                    break;
                case /* repeated opentelemetry.proto.metrics.v1.Metric metrics */ 2:
                    message.metrics.push(Metric.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string schema_url */ 3:
                    message.schemaUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScopeMetrics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* opentelemetry.proto.common.v1.InstrumentationScope scope = 1; */
        if (message.scope)
            InstrumentationScope.internalBinaryWrite(message.scope, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated opentelemetry.proto.metrics.v1.Metric metrics = 2; */
        for (let i = 0; i < message.metrics.length; i++)
            Metric.internalBinaryWrite(message.metrics[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string schema_url = 3; */
        if (message.schemaUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.schemaUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.ScopeMetrics
 */
export const ScopeMetrics = new ScopeMetrics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metric$Type extends MessageType<Metric> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.Metric", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "unit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "gauge", kind: "message", oneof: "data", T: () => Gauge },
            { no: 7, name: "sum", kind: "message", oneof: "data", T: () => Sum },
            { no: 9, name: "histogram", kind: "message", oneof: "data", T: () => Histogram },
            { no: 10, name: "exponential_histogram", kind: "message", oneof: "data", T: () => ExponentialHistogram },
            { no: 11, name: "summary", kind: "message", oneof: "data", T: () => Summary },
            { no: 12, name: "metadata", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue }
        ]);
    }
    create(value?: PartialMessage<Metric>): Metric {
        const message = { name: "", description: "", unit: "", data: { oneofKind: undefined }, metadata: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Metric>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metric): Metric {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string unit */ 3:
                    message.unit = reader.string();
                    break;
                case /* opentelemetry.proto.metrics.v1.Gauge gauge */ 5:
                    message.data = {
                        oneofKind: "gauge",
                        gauge: Gauge.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).gauge)
                    };
                    break;
                case /* opentelemetry.proto.metrics.v1.Sum sum */ 7:
                    message.data = {
                        oneofKind: "sum",
                        sum: Sum.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).sum)
                    };
                    break;
                case /* opentelemetry.proto.metrics.v1.Histogram histogram */ 9:
                    message.data = {
                        oneofKind: "histogram",
                        histogram: Histogram.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).histogram)
                    };
                    break;
                case /* opentelemetry.proto.metrics.v1.ExponentialHistogram exponential_histogram */ 10:
                    message.data = {
                        oneofKind: "exponentialHistogram",
                        exponentialHistogram: ExponentialHistogram.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).exponentialHistogram)
                    };
                    break;
                case /* opentelemetry.proto.metrics.v1.Summary summary */ 11:
                    message.data = {
                        oneofKind: "summary",
                        summary: Summary.internalBinaryRead(reader, reader.uint32(), options, (message.data as any).summary)
                    };
                    break;
                case /* repeated opentelemetry.proto.common.v1.KeyValue metadata */ 12:
                    message.metadata.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metric, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.description);
        /* string unit = 3; */
        if (message.unit !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.unit);
        /* opentelemetry.proto.metrics.v1.Gauge gauge = 5; */
        if (message.data.oneofKind === "gauge")
            Gauge.internalBinaryWrite(message.data.gauge, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* opentelemetry.proto.metrics.v1.Sum sum = 7; */
        if (message.data.oneofKind === "sum")
            Sum.internalBinaryWrite(message.data.sum, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* opentelemetry.proto.metrics.v1.Histogram histogram = 9; */
        if (message.data.oneofKind === "histogram")
            Histogram.internalBinaryWrite(message.data.histogram, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* opentelemetry.proto.metrics.v1.ExponentialHistogram exponential_histogram = 10; */
        if (message.data.oneofKind === "exponentialHistogram")
            ExponentialHistogram.internalBinaryWrite(message.data.exponentialHistogram, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* opentelemetry.proto.metrics.v1.Summary summary = 11; */
        if (message.data.oneofKind === "summary")
            Summary.internalBinaryWrite(message.data.summary, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated opentelemetry.proto.common.v1.KeyValue metadata = 12; */
        for (let i = 0; i < message.metadata.length; i++)
            KeyValue.internalBinaryWrite(message.metadata[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.Metric
 */
export const Metric = new Metric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Gauge$Type extends MessageType<Gauge> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.Gauge", [
            { no: 1, name: "data_points", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NumberDataPoint }
        ]);
    }
    create(value?: PartialMessage<Gauge>): Gauge {
        const message = { dataPoints: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Gauge>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Gauge): Gauge {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.metrics.v1.NumberDataPoint data_points */ 1:
                    message.dataPoints.push(NumberDataPoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Gauge, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.metrics.v1.NumberDataPoint data_points = 1; */
        for (let i = 0; i < message.dataPoints.length; i++)
            NumberDataPoint.internalBinaryWrite(message.dataPoints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.Gauge
 */
export const Gauge = new Gauge$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Sum$Type extends MessageType<Sum> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.Sum", [
            { no: 1, name: "data_points", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => NumberDataPoint },
            { no: 2, name: "aggregation_temporality", kind: "enum", T: () => ["opentelemetry.proto.metrics.v1.AggregationTemporality", AggregationTemporality, "AGGREGATION_TEMPORALITY_"] },
            { no: 3, name: "is_monotonic", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Sum>): Sum {
        const message = { dataPoints: [], aggregationTemporality: 0, isMonotonic: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Sum>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Sum): Sum {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.metrics.v1.NumberDataPoint data_points */ 1:
                    message.dataPoints.push(NumberDataPoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality */ 2:
                    message.aggregationTemporality = reader.int32();
                    break;
                case /* bool is_monotonic */ 3:
                    message.isMonotonic = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Sum, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.metrics.v1.NumberDataPoint data_points = 1; */
        for (let i = 0; i < message.dataPoints.length; i++)
            NumberDataPoint.internalBinaryWrite(message.dataPoints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality = 2; */
        if (message.aggregationTemporality !== 0)
            writer.tag(2, WireType.Varint).int32(message.aggregationTemporality);
        /* bool is_monotonic = 3; */
        if (message.isMonotonic !== false)
            writer.tag(3, WireType.Varint).bool(message.isMonotonic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.Sum
 */
export const Sum = new Sum$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Histogram$Type extends MessageType<Histogram> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.Histogram", [
            { no: 1, name: "data_points", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HistogramDataPoint },
            { no: 2, name: "aggregation_temporality", kind: "enum", T: () => ["opentelemetry.proto.metrics.v1.AggregationTemporality", AggregationTemporality, "AGGREGATION_TEMPORALITY_"] }
        ]);
    }
    create(value?: PartialMessage<Histogram>): Histogram {
        const message = { dataPoints: [], aggregationTemporality: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Histogram>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Histogram): Histogram {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.metrics.v1.HistogramDataPoint data_points */ 1:
                    message.dataPoints.push(HistogramDataPoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality */ 2:
                    message.aggregationTemporality = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Histogram, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.metrics.v1.HistogramDataPoint data_points = 1; */
        for (let i = 0; i < message.dataPoints.length; i++)
            HistogramDataPoint.internalBinaryWrite(message.dataPoints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality = 2; */
        if (message.aggregationTemporality !== 0)
            writer.tag(2, WireType.Varint).int32(message.aggregationTemporality);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.Histogram
 */
export const Histogram = new Histogram$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExponentialHistogram$Type extends MessageType<ExponentialHistogram> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.ExponentialHistogram", [
            { no: 1, name: "data_points", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ExponentialHistogramDataPoint },
            { no: 2, name: "aggregation_temporality", kind: "enum", T: () => ["opentelemetry.proto.metrics.v1.AggregationTemporality", AggregationTemporality, "AGGREGATION_TEMPORALITY_"] }
        ]);
    }
    create(value?: PartialMessage<ExponentialHistogram>): ExponentialHistogram {
        const message = { dataPoints: [], aggregationTemporality: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExponentialHistogram>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExponentialHistogram): ExponentialHistogram {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint data_points */ 1:
                    message.dataPoints.push(ExponentialHistogramDataPoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality */ 2:
                    message.aggregationTemporality = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExponentialHistogram, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint data_points = 1; */
        for (let i = 0; i < message.dataPoints.length; i++)
            ExponentialHistogramDataPoint.internalBinaryWrite(message.dataPoints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* opentelemetry.proto.metrics.v1.AggregationTemporality aggregation_temporality = 2; */
        if (message.aggregationTemporality !== 0)
            writer.tag(2, WireType.Varint).int32(message.aggregationTemporality);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.ExponentialHistogram
 */
export const ExponentialHistogram = new ExponentialHistogram$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Summary$Type extends MessageType<Summary> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.Summary", [
            { no: 1, name: "data_points", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SummaryDataPoint }
        ]);
    }
    create(value?: PartialMessage<Summary>): Summary {
        const message = { dataPoints: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Summary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Summary): Summary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.metrics.v1.SummaryDataPoint data_points */ 1:
                    message.dataPoints.push(SummaryDataPoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Summary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.metrics.v1.SummaryDataPoint data_points = 1; */
        for (let i = 0; i < message.dataPoints.length; i++)
            SummaryDataPoint.internalBinaryWrite(message.dataPoints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.Summary
 */
export const Summary = new Summary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NumberDataPoint$Type extends MessageType<NumberDataPoint> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.NumberDataPoint", [
            { no: 7, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue },
            { no: 2, name: "start_time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "as_double", kind: "scalar", oneof: "value", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "as_int", kind: "scalar", oneof: "value", T: 16 /*ScalarType.SFIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "exemplars", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Exemplar },
            { no: 8, name: "flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<NumberDataPoint>): NumberDataPoint {
        const message = { attributes: [], startTimeUnixNano: 0, timeUnixNano: 0, value: { oneofKind: undefined }, exemplars: [], flags: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NumberDataPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NumberDataPoint): NumberDataPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.common.v1.KeyValue attributes */ 7:
                    message.attributes.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* fixed64 start_time_unix_nano */ 2:
                    message.startTimeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* fixed64 time_unix_nano */ 3:
                    message.timeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* double as_double */ 4:
                    message.value = {
                        oneofKind: "asDouble",
                        asDouble: reader.double()
                    };
                    break;
                case /* sfixed64 as_int */ 6:
                    message.value = {
                        oneofKind: "asInt",
                        asInt: reader.sfixed64().toNumber()
                    };
                    break;
                case /* repeated opentelemetry.proto.metrics.v1.Exemplar exemplars */ 5:
                    message.exemplars.push(Exemplar.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 flags */ 8:
                    message.flags = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NumberDataPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.common.v1.KeyValue attributes = 7; */
        for (let i = 0; i < message.attributes.length; i++)
            KeyValue.internalBinaryWrite(message.attributes[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* fixed64 start_time_unix_nano = 2; */
        if (message.startTimeUnixNano !== 0)
            writer.tag(2, WireType.Bit64).fixed64(message.startTimeUnixNano);
        /* fixed64 time_unix_nano = 3; */
        if (message.timeUnixNano !== 0)
            writer.tag(3, WireType.Bit64).fixed64(message.timeUnixNano);
        /* double as_double = 4; */
        if (message.value.oneofKind === "asDouble")
            writer.tag(4, WireType.Bit64).double(message.value.asDouble);
        /* sfixed64 as_int = 6; */
        if (message.value.oneofKind === "asInt")
            writer.tag(6, WireType.Bit64).sfixed64(message.value.asInt);
        /* repeated opentelemetry.proto.metrics.v1.Exemplar exemplars = 5; */
        for (let i = 0; i < message.exemplars.length; i++)
            Exemplar.internalBinaryWrite(message.exemplars[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint32 flags = 8; */
        if (message.flags !== 0)
            writer.tag(8, WireType.Varint).uint32(message.flags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.NumberDataPoint
 */
export const NumberDataPoint = new NumberDataPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistogramDataPoint$Type extends MessageType<HistogramDataPoint> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.HistogramDataPoint", [
            { no: 9, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue },
            { no: 2, name: "start_time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "count", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "sum", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "bucket_counts", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 7, name: "explicit_bounds", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "exemplars", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Exemplar },
            { no: 10, name: "flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "min", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "max", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<HistogramDataPoint>): HistogramDataPoint {
        const message = { attributes: [], startTimeUnixNano: 0, timeUnixNano: 0, count: 0, bucketCounts: [], explicitBounds: [], exemplars: [], flags: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HistogramDataPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistogramDataPoint): HistogramDataPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.common.v1.KeyValue attributes */ 9:
                    message.attributes.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* fixed64 start_time_unix_nano */ 2:
                    message.startTimeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* fixed64 time_unix_nano */ 3:
                    message.timeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* fixed64 count */ 4:
                    message.count = reader.fixed64().toNumber();
                    break;
                case /* optional double sum */ 5:
                    message.sum = reader.double();
                    break;
                case /* repeated fixed64 bucket_counts */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bucketCounts.push(reader.fixed64().toNumber());
                    else
                        message.bucketCounts.push(reader.fixed64().toNumber());
                    break;
                case /* repeated double explicit_bounds */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.explicitBounds.push(reader.double());
                    else
                        message.explicitBounds.push(reader.double());
                    break;
                case /* repeated opentelemetry.proto.metrics.v1.Exemplar exemplars */ 8:
                    message.exemplars.push(Exemplar.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 flags */ 10:
                    message.flags = reader.uint32();
                    break;
                case /* optional double min */ 11:
                    message.min = reader.double();
                    break;
                case /* optional double max */ 12:
                    message.max = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistogramDataPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.common.v1.KeyValue attributes = 9; */
        for (let i = 0; i < message.attributes.length; i++)
            KeyValue.internalBinaryWrite(message.attributes[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* fixed64 start_time_unix_nano = 2; */
        if (message.startTimeUnixNano !== 0)
            writer.tag(2, WireType.Bit64).fixed64(message.startTimeUnixNano);
        /* fixed64 time_unix_nano = 3; */
        if (message.timeUnixNano !== 0)
            writer.tag(3, WireType.Bit64).fixed64(message.timeUnixNano);
        /* fixed64 count = 4; */
        if (message.count !== 0)
            writer.tag(4, WireType.Bit64).fixed64(message.count);
        /* optional double sum = 5; */
        if (message.sum !== undefined)
            writer.tag(5, WireType.Bit64).double(message.sum);
        /* repeated fixed64 bucket_counts = 6; */
        if (message.bucketCounts.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bucketCounts.length; i++)
                writer.fixed64(message.bucketCounts[i]);
            writer.join();
        }
        /* repeated double explicit_bounds = 7; */
        if (message.explicitBounds.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.explicitBounds.length; i++)
                writer.double(message.explicitBounds[i]);
            writer.join();
        }
        /* repeated opentelemetry.proto.metrics.v1.Exemplar exemplars = 8; */
        for (let i = 0; i < message.exemplars.length; i++)
            Exemplar.internalBinaryWrite(message.exemplars[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* uint32 flags = 10; */
        if (message.flags !== 0)
            writer.tag(10, WireType.Varint).uint32(message.flags);
        /* optional double min = 11; */
        if (message.min !== undefined)
            writer.tag(11, WireType.Bit64).double(message.min);
        /* optional double max = 12; */
        if (message.max !== undefined)
            writer.tag(12, WireType.Bit64).double(message.max);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.HistogramDataPoint
 */
export const HistogramDataPoint = new HistogramDataPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExponentialHistogramDataPoint$Type extends MessageType<ExponentialHistogramDataPoint> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint", [
            { no: 1, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue },
            { no: 2, name: "start_time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "count", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "sum", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "scale", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 7, name: "zero_count", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 8, name: "positive", kind: "message", T: () => ExponentialHistogramDataPoint_Buckets },
            { no: 9, name: "negative", kind: "message", T: () => ExponentialHistogramDataPoint_Buckets },
            { no: 10, name: "flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 11, name: "exemplars", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Exemplar },
            { no: 12, name: "min", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 13, name: "max", kind: "scalar", opt: true, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 14, name: "zero_threshold", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ExponentialHistogramDataPoint>): ExponentialHistogramDataPoint {
        const message = { attributes: [], startTimeUnixNano: 0, timeUnixNano: 0, count: 0, scale: 0, zeroCount: 0, flags: 0, exemplars: [], zeroThreshold: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExponentialHistogramDataPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExponentialHistogramDataPoint): ExponentialHistogramDataPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.common.v1.KeyValue attributes */ 1:
                    message.attributes.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* fixed64 start_time_unix_nano */ 2:
                    message.startTimeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* fixed64 time_unix_nano */ 3:
                    message.timeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* fixed64 count */ 4:
                    message.count = reader.fixed64().toNumber();
                    break;
                case /* optional double sum */ 5:
                    message.sum = reader.double();
                    break;
                case /* sint32 scale */ 6:
                    message.scale = reader.sint32();
                    break;
                case /* fixed64 zero_count */ 7:
                    message.zeroCount = reader.fixed64().toNumber();
                    break;
                case /* opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets positive */ 8:
                    message.positive = ExponentialHistogramDataPoint_Buckets.internalBinaryRead(reader, reader.uint32(), options, message.positive);
                    break;
                case /* opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets negative */ 9:
                    message.negative = ExponentialHistogramDataPoint_Buckets.internalBinaryRead(reader, reader.uint32(), options, message.negative);
                    break;
                case /* uint32 flags */ 10:
                    message.flags = reader.uint32();
                    break;
                case /* repeated opentelemetry.proto.metrics.v1.Exemplar exemplars */ 11:
                    message.exemplars.push(Exemplar.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional double min */ 12:
                    message.min = reader.double();
                    break;
                case /* optional double max */ 13:
                    message.max = reader.double();
                    break;
                case /* double zero_threshold */ 14:
                    message.zeroThreshold = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExponentialHistogramDataPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.common.v1.KeyValue attributes = 1; */
        for (let i = 0; i < message.attributes.length; i++)
            KeyValue.internalBinaryWrite(message.attributes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* fixed64 start_time_unix_nano = 2; */
        if (message.startTimeUnixNano !== 0)
            writer.tag(2, WireType.Bit64).fixed64(message.startTimeUnixNano);
        /* fixed64 time_unix_nano = 3; */
        if (message.timeUnixNano !== 0)
            writer.tag(3, WireType.Bit64).fixed64(message.timeUnixNano);
        /* fixed64 count = 4; */
        if (message.count !== 0)
            writer.tag(4, WireType.Bit64).fixed64(message.count);
        /* optional double sum = 5; */
        if (message.sum !== undefined)
            writer.tag(5, WireType.Bit64).double(message.sum);
        /* sint32 scale = 6; */
        if (message.scale !== 0)
            writer.tag(6, WireType.Varint).sint32(message.scale);
        /* fixed64 zero_count = 7; */
        if (message.zeroCount !== 0)
            writer.tag(7, WireType.Bit64).fixed64(message.zeroCount);
        /* opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets positive = 8; */
        if (message.positive)
            ExponentialHistogramDataPoint_Buckets.internalBinaryWrite(message.positive, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets negative = 9; */
        if (message.negative)
            ExponentialHistogramDataPoint_Buckets.internalBinaryWrite(message.negative, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* uint32 flags = 10; */
        if (message.flags !== 0)
            writer.tag(10, WireType.Varint).uint32(message.flags);
        /* repeated opentelemetry.proto.metrics.v1.Exemplar exemplars = 11; */
        for (let i = 0; i < message.exemplars.length; i++)
            Exemplar.internalBinaryWrite(message.exemplars[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* optional double min = 12; */
        if (message.min !== undefined)
            writer.tag(12, WireType.Bit64).double(message.min);
        /* optional double max = 13; */
        if (message.max !== undefined)
            writer.tag(13, WireType.Bit64).double(message.max);
        /* double zero_threshold = 14; */
        if (message.zeroThreshold !== 0)
            writer.tag(14, WireType.Bit64).double(message.zeroThreshold);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint
 */
export const ExponentialHistogramDataPoint = new ExponentialHistogramDataPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExponentialHistogramDataPoint_Buckets$Type extends MessageType<ExponentialHistogramDataPoint_Buckets> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets", [
            { no: 1, name: "offset", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "bucket_counts", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<ExponentialHistogramDataPoint_Buckets>): ExponentialHistogramDataPoint_Buckets {
        const message = { offset: 0, bucketCounts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExponentialHistogramDataPoint_Buckets>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExponentialHistogramDataPoint_Buckets): ExponentialHistogramDataPoint_Buckets {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 offset */ 1:
                    message.offset = reader.sint32();
                    break;
                case /* repeated uint64 bucket_counts */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.bucketCounts.push(reader.uint64().toNumber());
                    else
                        message.bucketCounts.push(reader.uint64().toNumber());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExponentialHistogramDataPoint_Buckets, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 offset = 1; */
        if (message.offset !== 0)
            writer.tag(1, WireType.Varint).sint32(message.offset);
        /* repeated uint64 bucket_counts = 2; */
        if (message.bucketCounts.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.bucketCounts.length; i++)
                writer.uint64(message.bucketCounts[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.ExponentialHistogramDataPoint.Buckets
 */
export const ExponentialHistogramDataPoint_Buckets = new ExponentialHistogramDataPoint_Buckets$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummaryDataPoint$Type extends MessageType<SummaryDataPoint> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.SummaryDataPoint", [
            { no: 7, name: "attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue },
            { no: 2, name: "start_time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "count", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "sum", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "quantile_values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SummaryDataPoint_ValueAtQuantile },
            { no: 8, name: "flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SummaryDataPoint>): SummaryDataPoint {
        const message = { attributes: [], startTimeUnixNano: 0, timeUnixNano: 0, count: 0, sum: 0, quantileValues: [], flags: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SummaryDataPoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummaryDataPoint): SummaryDataPoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.common.v1.KeyValue attributes */ 7:
                    message.attributes.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* fixed64 start_time_unix_nano */ 2:
                    message.startTimeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* fixed64 time_unix_nano */ 3:
                    message.timeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* fixed64 count */ 4:
                    message.count = reader.fixed64().toNumber();
                    break;
                case /* double sum */ 5:
                    message.sum = reader.double();
                    break;
                case /* repeated opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile quantile_values */ 6:
                    message.quantileValues.push(SummaryDataPoint_ValueAtQuantile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 flags */ 8:
                    message.flags = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SummaryDataPoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.common.v1.KeyValue attributes = 7; */
        for (let i = 0; i < message.attributes.length; i++)
            KeyValue.internalBinaryWrite(message.attributes[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* fixed64 start_time_unix_nano = 2; */
        if (message.startTimeUnixNano !== 0)
            writer.tag(2, WireType.Bit64).fixed64(message.startTimeUnixNano);
        /* fixed64 time_unix_nano = 3; */
        if (message.timeUnixNano !== 0)
            writer.tag(3, WireType.Bit64).fixed64(message.timeUnixNano);
        /* fixed64 count = 4; */
        if (message.count !== 0)
            writer.tag(4, WireType.Bit64).fixed64(message.count);
        /* double sum = 5; */
        if (message.sum !== 0)
            writer.tag(5, WireType.Bit64).double(message.sum);
        /* repeated opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile quantile_values = 6; */
        for (let i = 0; i < message.quantileValues.length; i++)
            SummaryDataPoint_ValueAtQuantile.internalBinaryWrite(message.quantileValues[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* uint32 flags = 8; */
        if (message.flags !== 0)
            writer.tag(8, WireType.Varint).uint32(message.flags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.SummaryDataPoint
 */
export const SummaryDataPoint = new SummaryDataPoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummaryDataPoint_ValueAtQuantile$Type extends MessageType<SummaryDataPoint_ValueAtQuantile> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile", [
            { no: 1, name: "quantile", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SummaryDataPoint_ValueAtQuantile>): SummaryDataPoint_ValueAtQuantile {
        const message = { quantile: 0, value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SummaryDataPoint_ValueAtQuantile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummaryDataPoint_ValueAtQuantile): SummaryDataPoint_ValueAtQuantile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double quantile */ 1:
                    message.quantile = reader.double();
                    break;
                case /* double value */ 2:
                    message.value = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SummaryDataPoint_ValueAtQuantile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double quantile = 1; */
        if (message.quantile !== 0)
            writer.tag(1, WireType.Bit64).double(message.quantile);
        /* double value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit64).double(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.SummaryDataPoint.ValueAtQuantile
 */
export const SummaryDataPoint_ValueAtQuantile = new SummaryDataPoint_ValueAtQuantile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Exemplar$Type extends MessageType<Exemplar> {
    constructor() {
        super("opentelemetry.proto.metrics.v1.Exemplar", [
            { no: 7, name: "filtered_attributes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => KeyValue },
            { no: 2, name: "time_unix_nano", kind: "scalar", T: 6 /*ScalarType.FIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "as_double", kind: "scalar", oneof: "value", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "as_int", kind: "scalar", oneof: "value", T: 16 /*ScalarType.SFIXED64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "span_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "trace_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Exemplar>): Exemplar {
        const message = { filteredAttributes: [], timeUnixNano: 0, value: { oneofKind: undefined }, spanId: new Uint8Array(0), traceId: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Exemplar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Exemplar): Exemplar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated opentelemetry.proto.common.v1.KeyValue filtered_attributes */ 7:
                    message.filteredAttributes.push(KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* fixed64 time_unix_nano */ 2:
                    message.timeUnixNano = reader.fixed64().toNumber();
                    break;
                case /* double as_double */ 3:
                    message.value = {
                        oneofKind: "asDouble",
                        asDouble: reader.double()
                    };
                    break;
                case /* sfixed64 as_int */ 6:
                    message.value = {
                        oneofKind: "asInt",
                        asInt: reader.sfixed64().toNumber()
                    };
                    break;
                case /* bytes span_id */ 4:
                    message.spanId = reader.bytes();
                    break;
                case /* bytes trace_id */ 5:
                    message.traceId = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Exemplar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated opentelemetry.proto.common.v1.KeyValue filtered_attributes = 7; */
        for (let i = 0; i < message.filteredAttributes.length; i++)
            KeyValue.internalBinaryWrite(message.filteredAttributes[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* fixed64 time_unix_nano = 2; */
        if (message.timeUnixNano !== 0)
            writer.tag(2, WireType.Bit64).fixed64(message.timeUnixNano);
        /* double as_double = 3; */
        if (message.value.oneofKind === "asDouble")
            writer.tag(3, WireType.Bit64).double(message.value.asDouble);
        /* sfixed64 as_int = 6; */
        if (message.value.oneofKind === "asInt")
            writer.tag(6, WireType.Bit64).sfixed64(message.value.asInt);
        /* bytes span_id = 4; */
        if (message.spanId.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.spanId);
        /* bytes trace_id = 5; */
        if (message.traceId.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.traceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message opentelemetry.proto.metrics.v1.Exemplar
 */
export const Exemplar = new Exemplar$Type();
